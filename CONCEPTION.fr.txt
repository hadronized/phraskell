Ceci est un document de conception.

On va avoir besoin de refactoriser un petit peu. Déjà, le module Phraskell ne va plus contenir que la gestion
des options CLI et les appels en fonction. Ensuite, on va avoir besoin de gérer le viewer. Pour ça on va créer
un module UI, qui contiendra toute l’interface utilisateur. Dedans on y mettra premièrement une data Viewer :

data Viewer = Viewer {
    viewerZoom      :: Float -- current zoom value
  , viewerX         :: Float -- current x displacement value
  , viewerY         :: Float -- current y displacement value
  , viewerColorSeed :: Int   -- color seed value
}

On mettra plutôt cette data dans le module Viewer.

Cette data va nous permettre de stocker à tout moment les paramètres de notre fractale. viewerZoom nous donne
le niveau de zoom actuel, viewer{X,Y} nous donnent la position actuelle de la fractale. Avec ces 3 valeurs, on
peut ainsi retrouver une image très facilement (il suffit de logger le viewer).

On va ensuite avoir besoin d’une fonction qui va gérer les évènements. Il y a actuellement un certain nombre
d’évènements :
  · onViewerUpdate: demande de mise à jour du viewer; arrive lorsque l’on bouge la souris par exemple ;
  · onScreenshot: demande de screenshot ;
  · onIterFrameUpdate: demande de mise à jour de la frame d’itération; arrive lorsque l’utilisateur demande
    une mise à jour de la fractale en utilisant les trois premiers paramètres du viewer ;
  · onFractalFrameUpdate: demande de mise à jour de la frame de la fractale, par exemple après un appel à
    onIterFrameUpdate, ou une mise à jour du color seed.

treatEvents :: App -> IO (Bool,App)
treatEvents app = do
  event <- waitEvent -- TODO: while waitEvent instead
  case event of
    NoEvent -> nochange
    Quit    -> quit
    KeyUp k -> case symKey k of
      SDLK_ESCAPE -> quit
      SDLK_c      -> alter $ onViewerUpdate ModifColorSeed)
      SDLK_s      -> alter $ onScreenshot
      _           -> loopback
    MouseButtonUp b -> case b of
      ButtonLeft -> alter $ onIterFrameUpdate
    _       -> loopback
 where quit = return (False,app)
       nochange = return (True,app)
       alter f = return (True,f app)
       loopback = treatEvents app

Le code de chaque évènement doit être rempli dans un module qui va bien.

Bon maintenant, lorsqu’un utilisateur génère un évènement (pas SDL, un
évènement phraskell, donc on*), on doit appeler l’implémentation de cet
évènement. Les évènements sont utilisés dans le module UI, on va donc les
renseigner dans le module UI.Impl. Le nom du module est un peu naze, mais on
verra après. 

On va commencer par travailler sur onIterFrameUpdate, qui est appelé lorsque
l’on veut mettre à jour la fractale. Cette fonction va avoir besoin d’un certain
nombre de données pour pouvoir mettre à jour la fractale correctement :
  · l’application
    · le viewer
    · la surface de la fractale
  · la position de la souris
  · le facteur de zoom
Dans le viewer, nous trouverons les valeurs actuelles de la fractale (offsets
x et y ainsi que le zoom). La surface de la fractale va être utile car nous allons
la mettre à jour. La position de la souris va nous permettre de calculer les
nouveaux offsets. Idem pour le facteur de zoom. La première chose que cette fonction
doit faire, c’est de mettre à jour le viewer. C’est à la fois triviale et complexe :
la mise à jour du zoom est basique : currentZoom * zf. Si le zoom actuel est 0.5 et
que l’on passe 2, on avoir un nouveau zoom à 1, ce qui est correct. La mise à jour
des offsets est par contre moins trivial. L’idée, c’est de calculer de combien on
doit se déplacer localement. On doit prendre la position de la souris et la passer
en coordonnées cartésienne. Puis, on calcule le Δ(souris,offsets). Les offsets 
représentent en fait l’origine du repère. Donc ce Δ va nous donner une distance 
que l’on doit parcourir pour avoir la nouvelle position. Mais attention ! La
position de la souris est locale à l’image, qui peut éventuellement être zoomée !
Il faut donc la multiplier par le niveau de zoom pour avoir un Δ correct, et pouvoir
l’additionner aux offsets actuels. On a donc :

  newZoom = currentZoom * zf
  newXY = offXY + (x :+ y)*currentZoom

On peut ensuite simplement appeler la fonction mkIterFrame avec ces nouveaux paramètres,
et on va avoir tout bien correctement !

-----

On doit refactoriser encore et encore. Déjà, le point d’entrée est vraiment dégueulasse.
Il faut factoriser cela car c’est vraiment moche. On peut éventuellement utiliser des
monade transformers, on va voir cela.

La partie CLI est bien écrite. Elle est concise. On va cependant la rendre plus explicite.
Flag va devenir CLIFlag, pour bien montrer que c’est un flag CLI. La fonction usage reste
inchangée. La fonction options est bonne mais il faut prendre en compte CLIFlag. parseOpts
parse les options passées en paramètre et retourne peut-être des CLIFlag. Ici,
le comportement n’est pas celui voulu, bien que cela marche. On voudrait en fait que si
notre opération IO échoue, c’est à dire que la ligne de commande CLI est mal formée, alors
on retourne une erreur. On va donc utiliser Either, et même EitherT ! Et là on aura un truc
propre de chez propre. Ensuite, initApp, qui permet d’initialiser un application, n’est pas
terrible, car elle prend une app et lui applique les flags, sauf que l’application que l’on
passe doit être créée, et c’est chiant à créer. On va donc passer uniquement des flags, et
cette fonction va devenir createApp. modifyAppWithOpt va changer de nom pour devenir 
alterAppOpt, et son implémentation reste la même.
Finalement, il nous faudra une fonction version.

Normalement après tout ça, on devrait avoir une main plus simple.

Bon la fonction qui crée l’application doit-être pure. Le problème avec
